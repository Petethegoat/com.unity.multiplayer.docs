---
id: session-management
title: Session Management
---
In a multiplayer game, we might want to have some session management to allow players to correctly reconnect to the game. What this exactly means might vary depending on the game, but the core idea is that there is some data that needs to be kept when a player disconnects, and assigned back to them when they reconnect. We must also make sure that the data is reassigned to the right player.

## Linking data to players
To reassign data to the right player when they reconnect, we need a way to link this data to the player. The clientId generated by NGO cannot be used, however, since it is generated when a player connects and is disposed of when they disconnect. It can then be assigned to a different player when if they connect to the server after the first one disconnected. To properly link data to a specific player, we need an ID that is not tied to the current connection, that persists through time, and that is unique to that player. A few solutions can be used, such as a login system with unique player accounts, or simply a Globally Unique Identifier (GUID). A GUID can be generated via `System.Guid.NewGuid()` and then saved to the `PlayerPrefs` client side, for example.

When we have such a way to uniquely identify a player, we can then use it to map each player's data that would be needed when reconnecting, such as the current state of their character for example. Then, we need to make sure this data is up to date and to keep it after a player disconnects. We could add a timeout after which we can purge the data or we could decide to clear all data only when a session completes. And finally, once we have up to date data that we can link to a specific player who disconnected earlier, we can now handle reconnection properly.

## Handling reconnection
In cases where we use a Player Object, a new Default Player Prefab will be automatically spawned when any player connects to the game (including if they are reconnecting). We can then use the player's previously saved session data to update that object so that its state returns to what it was before disconnecting. In those cases, we would need to keep all the important data that we want to restore and map it to the player using our identification system.

In cases where we use the ownership model, we could instead keep the objects that a player owns when they disconnects, and set the reconnected player as their new owner. To accomplish this, the only data we would need to keep would be the mapping between those objects and their owning player's identifier, then when a player reconnects we could use this mapping to set them as the new owner.

## Example using the Player Object model
Here is an example from the Boss Room sample, showing some simple session management. The game uses the Player Object model and a GUID to identify unique players.

```csharp reference
https://github.com/Unity-Technologies/com.unity.multiplayer.samples.coop/blob/develop/Assets/BossRoom/Scripts/Shared/Net/ConnectionManagement/SessionManager.cs
```

This class allows BossRoom to handle player session data, by providing mechanisms to initialize, obtain and edit that data, and to associate it to a specific player. It also handles the clearing of data that is no longer used and the reinitialization of data between sessions.

In this case, since game sessions are quite short, the session data is only cleared for disconnected players when a session ends, and when a new one begins, which makes sure that if a player disconnects during a session and then reconnects during the next session, the game properly treats it as a new connection. The definition of when a session ends and when a session starts might vary from game to game, but in BossRoom, a session is considered to start after character selection and end when the players win or loose the game and enter the post-game scene. In other cases, one might want to add a timeout to session data and clear it after a specified time instead.