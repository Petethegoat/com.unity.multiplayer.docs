---
id: session-management
title: Session Management
---
In a multiplayer game, we might want to have some session management to allow players to correctly reconnect to the game. What this exactly means might vary depending on the game, but the core idea is that there is some data that needs to be kept when a player disconnects, and assigned back to them when they reconnect. We must also make sure that the data is reassigned to the right player.

## Linking data to players
To reassign data to the right player when they reconnect, we need a way to link this data to the player. The clientId generated by NGO cannot be used, however, since it is generated when a player connects and is disposed of when they disconnect. It can then be assigned to a different player when if they connect to the server after the first one disconnected. To properly link data to a specific player, we need an ID that is not tied to the current connection, that persists through time, and that is unique to that player. A few solutions can be used, such as a login system with unique player accounts, or simply a Globally Unique Identifier (GUID). A GUID can be generated via `System.Guid.NewGuid()` and then saved to the `PlayerPrefs` client side, for example.

When we have such a way to uniquely identify a player, we can then use it to map each player's data that would be needed when reconnecting, such as the current state of their character for example. Then, we need to make sure this data is up to date and to keep it after a player disconnects. We could add a timeout after which we can purge the data or we could decide to clear all data only when a session completes. And finally, once we have up to date data that we can link to a specific player who disconnected earlier, we can now handle reconnection properly.

## Handling reconnection
In cases where we use a Player Object, a new Default Player Prefab will be automatically spawned when any player connects to the game (including if they are reconnecting). We can then use the player's previously saved session data to update that object so that its state returns to what it was before disconnecting. In those cases, we would need to keep all the important data that we want to restore and map it to the player using our identification system.

In cases where we use the ownership model, we could instead keep the objects that a player owns when they disconnects, and set the reconnected player as their new owner. To accomplish this, the only data we would need to keep would be the mapping between those objects and their owning player's identifier, then when a player reconnects we could use this mapping to set them as the new owner.

## Example using the Player Object model
Here is an example from the Boss Room sample, showing some simple session management. The game uses the Player Object model and a GUID to identify unique players. In that example, each player's data is saved in the `m_ClientData` dictionary, and each of their clientId is mapped to their Guid in `m_ClientIDToGuid`. The saved data is represented by the generic type `T`, which is a struct implementing the `ISessionPlayerData` interface. This struct contains all the data required. An implementation could contain, for example, the character's current hit points, position, class, etc. The interface has two properties, `IsConnected` and `ClientID`, and the method `Reinitialize`. `IsConnected` is used in the `OnClientApprovalCheck` method to differentiate between a duplicate connection and a reconnection, and is set when a player connects to the game and is unset when they disconnect. `ClientID` is used to link the player's session data with their current ClientID. It is updated when they connect or reconnect. Finally, `Reinitialize` is called in the `OnSessionEnded` method for each player's session data. This should reset the data of the player's session to represent a new session.

When a player is connecting, their session data is created in the `OnClientApprovalCheck` method, which in this case is called by another script as part of `NetworkManager`'s `ConnectionApprovalCallback`. It is also in this method that we verify if data already exists for this GUID, and if so, check wether it is a duplicate login or a reconnection. In the case of a reconnection, we simply update the mapping of the player's GUID to their new client id. This data can then be accessed via the `GetPlayerData` method, from wherever it is needed. This data is updated via the `SetPlayerData` method.

Finally, when a player disconnects, `OnClientDisconnect` is called, which updates the `IsConnected` property. When the session is over, `OnSessionEnded` clears all the data from players who disconnected but did not reconnect, so that if a new session is started, a reconnecting player would be treated as a new player, as intended. The rest of the data is reinitialized but stays kept in `m_ClientData` until the server is shut down. When a new session is started, `OnSessionStarted` also clears all the data from disconnected players, in case players disconnect after the session ends, but before it starts again.

```csharp reference
https://github.com/Unity-Technologies/com.unity.multiplayer.samples.coop/blob/develop/Assets/BossRoom/Scripts/Shared/Net/ConnectionManagement/SessionManager.cs
```